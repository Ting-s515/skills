# 範例：重複通知（Repeat）— 多層分支 + 迴圈 + 外部服務

## 優化前（模糊描述）

```
查詢符合的告警資料，看 Redis 有沒有 Key，
有的話就看 TTL 算一下時間，找到超過的那筆就發，
沒超過就跳過，如果截止時間過了也跳過。
沒有 Key 的話就直接找一筆能發的發出去，然後設 Redis。
```

## 優化後（結構化描述）

**比對條件：** 主類別（`MainCategory`）+ 次類別（`SubCategory`）+ 告警編號（`AlertId`）

**處理流程：**

1. 查詢主類別、次類別與告警編號皆相符的告警資料，排除 `SendDeadline` 小於當前主機時間的資料（`SendDeadline` 為 `NULL` 視為無截止時間限制，不排除），符合條件的資料依 pk `Id` 由小到大排序
2. 以主類別（`MainCategory`）+ 次類別（`SubCategory`）+ 告警編號（`AlertId`）作為 Redis Key，檢查快取中是否存在對應的 Key
3. **Key 存在時（快取期間內）：** 取得該 Key 的剩餘過期秒數（TTL），計算「當前主機時間 + TTL 剩餘秒數」作為預估下次可發送時間，依序遍歷該批次資料，尋找第一筆超過可發送時間的資料
4. 承接第三點，若遍歷到某筆資料超過可發送時間，則檢查該筆資料的截止時間（`SendDeadline`）是否已過：
   - **未過期：** 將該筆資料加入待發送清單，寫入 Redis 快取，結束遍歷
   - **已過期：** 重新取得 Redis Key 的 TTL 並重新計算可發送時間，繼續往下遍歷下一筆資料，直到找到符合條件的資料或遍歷完該批次所有資料
5. **Key 不存在時（快取已過期或首次觸發）：** 遍歷該批次資料，檢查該筆截止時間是否已過，如果已過期則繼續遍歷下一筆，如果未過期則加入待發送清單，結束遍歷，並寫入 Redis 快取，過期時間設定為 `IntervalMinutes`

## 展示重點

| 項目 | 說明 |
|------|------|
| 複雜度 | 高（多層分支 + 迴圈 + 外部服務互動） |
| 優化要點 | 步驟串接（承接第 N 點）、嵌套分支縮排、迴圈內重新計算邏輯 |
